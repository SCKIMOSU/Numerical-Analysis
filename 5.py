# -*- coding: utf-8 -*-
"""Chapter5.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/18jFwIBnFS75RQbAaPvkmIw9wLqkwZG_C
"""

# Commented out IPython magic to ensure Python compatibility.
# 리스트 5-1-(1)
import numpy as np
import matplotlib.pyplot as plt
# %matplotlib inline


# 데이터 생성 --------------------------------
np.random.seed(seed=1) # 난수를 고정
X_min = 4 # X의 하한(표시 용)
X_max = 30 # X의 상한(표시 용)
X_n = 16 # X의 상한(표시 용)
X = 5 + 25 * np.random.rand(X_n)
# https://nittaku.tistory.com/443
#
# np.random.rand(X_n) --> [0,1] @ 100%
#  25 * [0,1] @ 100%  --> [0,25] @ 100%
#  5 + [0,25] @ 100% --> [5,30] @ 100%
# 따라서 X는 5에서 30세에 100% 가 나타나는 균등 분포

Prm_c = [170, 108, 0.2] # 생성 매개 변수
T = Prm_c[0] - Prm_c[1] * np.exp(-Prm_c[2] * X) \
+ 4 * np.random.randn(X_n) # (A)

# Prm_c[1] * np.exp(-Prm_c[2] * X) 이 부분이 170 cm 에서
# X: [5,30] @ 100%
# Prm_c[2] * X :  0.2 * [5,30] @ 100% = [1,6] @ 100%
# -Prm_c[2] * X :  -1* [1,6] @ 100% = [-6,-1]@ 100%
# np.exp(-Prm_c[2] * X) : [0.0025,0.3679]@ 100%
# Prm_c[1] * np.exp(-Prm_c[2] * X) = 108 * [0.0025,0.3679]@ 100%
  # 108*np.exp(-6) = 0.268
  # 108*np.exp(-1) = 39.731
# Prm_c[1] * np.exp(-Prm_c[2] * X) :  [0.268, 39.731]@ 100%
# Prm_c[0] - Prm_c[1] * np.exp(-Prm_c[2] * X) = 170-[0.268, 39.731]@ 100%
  # 170-108*np.exp(-6) = 169.73
  # 170-108*np.exp(-1) = 130.269
  # Prm_c[0] - Prm_c[1] * np.exp(-Prm_c[2] * X) : [130.269, 169.73]@ 100%

#  4 * np.random.randn(X_n) : 4*[-1, 1] @ 68% =[-4, 4] @ 68%
#  Prm_c[0] - Prm_c[1] * np.exp(-Prm_c[2] * X) + 4 * np.random.randn(X_n)
#  [130.269, 169.73]@ 100% + [-4, 4] @ 68%
#  [126.269, 173.73]@ 68% 정규분포

#Prm_c[2] * X
# array([3.08652401, 3.79344914, 1.70193469, 1.99050745, 5.00372284,
#        5.84130788, 2.56712089, 4.46161308, 5.38194576, 5.47303332,
#        1.42522106, 1.19527392, 1.8491521 , 5.39071252, 1.49173417,
#        3.10553813])
# np.exp(-Prm_c[2] * X)
# array([0.04566039, 0.0225178 , 0.18233043, 0.13662608, 0.00671291,
#       0.00290504, 0.07675622, 0.01154373, 0.00459886, 0.00419848,
#       0.2404553 , 0.30262105, 0.15737054, 0.00455872, 0.22498216,
#       0.0448004 ])
#np.exp(-1)
#np.exp(-6)
#Prm_c[1]
# 108
#np.exp(-6)*108
# 0.26770523507996674
#np.exp(-12)*108
# 0.0006635749341594466
#np.exp(-1)*108
#39.73097964651577
#Prm_c[0] - Prm_c[1] * np.exp(-Prm_c[2] * X)
#array([165.06867746, 167.56807753, 150.30831365, 155.24438362,
#       169.27500579, 169.6862556 , 161.71032855, 168.75327745,
#       169.50332259, 169.54656443, 144.03082727, 137.3169266 ,
#       153.00398118, 169.50765781, 145.70192673, 165.16155638])
#Prm_c[0] -  np.exp(-6)*108
#169.73229476492003
#Prm_c[0] -  np.exp(-1)*108
# 130.26902035348422
# [130, 169]@100%
# 4 * np.random.randn(X_n)
# array([-2.68498452, -0.0506584 , -4.46924139,  0.93766279,  6.63920871,
#         2.96817664, -0.76734221, -3.55051586, -2.98863318,  6.7698184 ,
#         0.20323102, -2.54798259,  0.76366194,  8.40102055,  0.48063581,
#        2.46881244])
# [-4, 4]@68%

# [130, 169]@100% + [-4, 4]@68%
# [126, 173]@68%


np.savez('ch5_data.npz', X=X, X_min=X_min, X_max=X_max, X_n=X_n, T=T) # (B)

# 리스트 5-1-(2)
print(X)

# 리스트 5-1-(3)
print(np.round(X, 2))

# 리스트 5-1-(4)
print(np.round(T, 2))

X=np.round(X, 2)
T=np.round(T, 2)

# 리스트 5-1-(5)
# 데이터 그래프 ------------------------------
plt.figure(figsize=(4, 4))
plt.plot(X, T, marker='o', linestyle='None',
         markeredgecolor='black', color='cornflowerblue')
plt.xlim(X_min, X_max)
plt.grid(True)
plt.xlabel('Age')
plt.ylabel('Height')
plt.show()

# 리스트 5-1-(6)
from mpl_toolkits.mplot3d import Axes3D
# 평균 오차 함수 ------------------------------
def mse_line(x, t, w): # 나이, 키, (나이 , w[0]), (키 , w[1]) : 튜플 자료형
    # x=X ; t=T; w= (x0[i0] , x1[i1]) ; w[0] = -25.0; w[1]= 120.0
    y = w[0] * x + w[1] # (나이 , w[0]), (키 , w[1])
    mse = np.mean((y - t)**2)
    return mse

# 계산 --------------------------------------
xn = 100 # 등고선 표시 해상도
w0_range = [-25, 25] #나이
w1_range = [120, 170] # 키
x0 = np.linspace(w0_range[0], w0_range[1], xn) #나이
x1 = np.linspace(w1_range[0], w1_range[1], xn) # 키
xx0, xx1 = np.meshgrid(x0, x1) # 전수검사
J = np.zeros((len(x0), len(x1)))
for i0 in range(xn):
    for i1 in range(xn):
        J[i1, i0] = mse_line(X, T, (x0[i0], x1[i1])) # 튜플 자료형
        #  나이, 키, (나이 , w[0]), (키 , w[1])
# 표시 --------------------------------------
plt.figure(figsize=(9.5, 4))
plt.subplots_adjust(wspace=0.5)

ax = plt.subplot(1, 2, 1, projection='3d')
# 오차함수 그리는 부분, 그리드 격자(xx0, xx1) 위에 평균제곱오치를 나타낸는
# 오차함수 J 를 3차원으로 그리는 부분,
# 평면은 나이, 키를 구성하는 가중치값 두 개와 3차원이 되는 z 축은 오차함수 J가 됨
ax.plot_surface(xx0, xx1, J, rstride=10, cstride=10, alpha=0.3,
                color='blue', edgecolor='black')
# xx0[0] = array([-25.        , -24.49494949, -23.98989899, -23.48484848,
#        -22.97979798, -22.47474747, -21.96969697, -21.46464646,
#        -20.95959596, -20.45454545, -19.94949495, -19.44444444,
#        -18.93939394, -18.43434343, -17.92929293, -17.42424242, ...,
#         21.46464646,  21.96969697,  22.47474747,  22.97979798,
#         23.48484848,  23.98989899,  24.49494949,  25.        ])  --> 기울기 값의 변화

# xx1[0] =  array([120., 120., 120., 120., 120., 120., 120., 120., 120., 120., 120.,
#        120., 120., 120., 120., 120., 120., 120., 120., 120., 120., 120.,
#        120., 120., 120., 120., 120., 120., 120., 120., 120., 120., 120., ...,
#        120., 120., 120., 120., 120., 120., 120., 120., 120., 120., 120.,
#        120., 120., 120., 120., 120., 120., 120., 120., 120., 120., 120.,
#        120.])      --> 절편 고정

# J[0]
# array([1.88152243e+05, 1.81302217e+05, 1.74579270e+05, 1.67983402e+05,
#        1.61514613e+05, 1.55172903e+05, 1.48958272e+05, 1.42870720e+05,
# ...
#        3.19825950e+04, 2.91990971e+04, 2.65426781e+04, 2.40133382e+04,
#        2.16110772e+04, 1.93358953e+04, 1.71877923e+04, 1.51667684e+04,
#        1.32728235e+04, 1.15059575e+04, 9.86617061e+03, 8.35346268e+03,
#        6.96783376e+03, 5.70928384e+03, 4.57781293e+03, 3.57342101e+03,
#        2.69610810e+03, 1.94587420e+03, 1.32271929e+03, 8.26643389e+02,
#        4.57646490e+02, 2.15728593e+02, 1.00889700e+02, 1.13129810e+02,
#        2.52448922e+02, 5.18847037e+02, 9.12324156e+02, 1.43288028e+03,
#        2.08051540e+03, 2.85522953e+03, 3.75702266e+03, 4.78589479e+03,
#        5.94184592e+03, 7.22487606e+03, 8.63498520e+03, 1.01721733e+04,
# ...
#        7.18083740e+04, 7.61413002e+04, 8.06013054e+04, 8.51883897e+04,
#        8.99025529e+04, 9.47437951e+04, 9.97121163e+04, 1.04807517e+05,
#        1.10029996e+05, 1.15379554e+05, 1.20856191e+05, 1.26459907e+05])

ax.set_xticks([-20, 0, 20])
ax.set_yticks([120, 140, 160])
ax.view_init(20, -60)

plt.subplot(1, 2, 2)
# 등고선을 나타내는 contour 함수를 사용하여 오차함수를 그려보자
# xx0, xx1의 2차원 평면에 J의 높고 낮음을 등고선 형태로 나타내면,
# 높고 낮음이 있음으로 등고선이 3차원 역할을 함
cont = plt.contour(xx0, xx1, J, 30, colors='black',
                   levels=[100, 1000, 10000, 100000])
# 등고선의 높고 낮음, 높이 차이를 clabel 함수로 나타냄
cont.clabel(fmt='%1.0f', fontsize=8)
plt.grid(True)
plt.show()

# 리스트 5-1-(7)
# 평균 제곱 오차의 기울기 ------------------------

# 머신 규칙(모델링+손실함수, B) 에 대해서 손실함수 해를 경사하강법 (B) 으로 구하기
# 경사하강법 (B) 에 대해 해석해 A를 통해
# 단번에 w* ( 𝑥_𝑘^(new )  ) 를 구하는 것이 아니라,
# 편미분 (𝛻𝑓(𝑥_𝑘 ), 순간변화율, 미분값, 기울기값) 의
# 반복 계산을 통해 해 w* ( 𝑥_𝑘^(new )  ) 를 구한다

def dmse_line(x, t, w): # 나이, 키, (나이 , w[0]), (키 , w[1])
    # w_i[i - 1] = [10, 165]
    # w=[10, 165]; x=X; t=T
    y = w[0] * x + w[1]
    # array([319.32620059, 354.67245711, 250.09673465, 264.52537227,
    #        415.18614217, 457.06539393, 293.35604454, 388.08065392,
    #        434.09728807, 438.65166588, 236.26105284, 224.76369581,
    #        257.45760489, 434.53562586, 239.58670846, 320.27690625])

    d_w0 = 2 * np.mean((y - t) * x)
    # d_w0 = 4666.79269099332
    d_w1 = 2 * np.mean(y - t)
    # d_w1= 292.60730896834195
    return d_w0, d_w1  # 4666.8  292.6

# 리스트 5-1-(8)
# # 나이 = 10, 키 165, 에서 3차원 오차함수의 기울기 구하기
# 𝛻𝑓(𝑥_𝑘 ) , 순간변화율, 미분값, 기울기값 구하기
d_w = dmse_line(X, T, [10, 165])
print(np.round(d_w, 1))
# [4666.8  292.6]

# 리스트 5-1-(9)
# 경사하강법  ------------------------------------
def fit_line_num(x, t):
    # x=X; t=T
    w_init = [10.0, 165.0] # 초기 매개 변수, 오픈법 시작 지점
    # w_init의 나이 값 10은 원래 나이 데이터 X 에는 없는 값이다
    # w_init의 키 값 165는 원래 키 데이터 T 에는 없는 값이다

    alpha = 0.001 # 학습률
    i_max = 100000 # 반복의 최대 수
    eps = 0.1 # 반복 종료,  기울기의 절대 값의 한계

    w_i = np.zeros([i_max, 2])
    w_i[0, :] = w_init
    # w_i 는 나이 값, 키 값 변화를 담는 그릇
    for i in range(1, i_max):
        dmse = dmse_line(x, t, w_i[i - 1]) # w_i[i - 1] = [10, 165]
        # x=X (나이); t=T (키)
        # 𝛻𝑓(𝑥_𝑘 ) 나이에 대해 경사하강법 적용

        w_i[i, 0] = w_i[i - 1, 0] - alpha * dmse[0]
        # 𝛻𝑓(𝑥_𝑘 ) 나이에 대해 경사하강법 적용
        w_i[i, 1] = w_i[i - 1, 1] - alpha * dmse[1]
        # 𝛻𝑓(𝑥_𝑘 ) 키에 대해 경사하강법 적용
        if max(np.absolute(dmse)) < eps: # 종료판정, np.absolute는 절대치
            print("break i ", i)
            print("break dmse ", dmse)
            # break i  13820
            # break dmse  (-0.005793591015883948, 0.09999091251416559)
            break

    w0 = w_i[i, 0]
    w1 = w_i[i, 1]
    print("w0*, w1* = ", np.round(w_i[i], 2))
    # w0*, w1* =  [  1.54 136.18]
    w_i = w_i[:i, :]

    return w0, w1, dmse, w_i

#  w0, w1, dmse, w_i 확인
# (1.5399473562672923, 136.1761603274906,
#(-0.005793591015883948, 0.09999091251416559),
# array([[ 10.        , 165.        ],
#        [  4.95371356, 164.69820279],
#        [  2.4301957 , 164.54258086],

# 메인 ------------------------------------
plt.figure(figsize=(4, 4)) # MSE의 등고선 표시
xn = 100 # 등고선 해상도
# xn = 1000 # 등고선 해상도
w0_range = [-25, 25]
w1_range = [120, 170]
x0 = np.linspace(w0_range[0], w0_range[1], xn)
x1 = np.linspace(w1_range[0], w1_range[1], xn)
xx0, xx1 = np.meshgrid(x0, x1)
J = np.zeros((len(x0), len(x1)))
for i0 in range(xn):
    for i1 in range(xn):
        J[i1, i0] = mse_line(X, T, (x0[i0], x1[i1])) # x0[0], x1[0] = (-25.0, 120.0)
cont = plt.contour(xx0, xx1, J, 30, colors='black',
                   levels=(100, 1000, 10000, 100000))
cont.clabel(fmt='%1.0f', fontsize=8)
plt.grid(True)


# 경사하강법 호출
# 디버깅 포인트
W0, W1, dMSE, W_history = fit_line_num(X, T)
# 결과보기
print('반복 횟수 {0}'.format(W_history.shape[0]))
print('W=[{0:.6f}, {1:.6f}]'.format(W0, W1))
print('dMSE=[{0:.6f}, {1:.6f}]'.format(dMSE[0], dMSE[1]))
print('MSE={0:.6f}'.format(mse_line(X, T, [W0, W1])))

# 디버깅 포인트
plt.plot(W_history[:, 0], W_history[:, 1], '.-',
         color='gray', markersize=10, markeredgecolor='cornflowerblue')

# plt.plot(W_history[0:100, 0], W_history[0:100, 1], '.-',  [0에서 100까지 히스토리를 찍어보기]
 #        color='gray', markersize=10, markeredgecolor='cornflowerblue')
# W_history[0, 0], W_history[0, 1] 부터 먼저 시작
# plt.plot(W_history[0, 0], W_history[0, 1], '.-',
#     ...:          color='gray', markersize=10, markeredgecolor='cornflowerblue')
# np.round([W_history[1, 0], W_history[1, 1]], 2)
# array([  4.95, 164.7 ])

plt.show()


# np.round([W_history[1, 0], W_history[1, 1]], 2)
# array([  4.95, 164.7 ])
plt.show()

# 리스트 5-1-(10)
# 선 표시 ----------------------------------
def show_line(w):
    xb = np.linspace(X_min, X_max, 100)
    y = w[0] * xb + w[1]
    plt.plot(xb, y, color=(.5, .5, .5), linewidth=4)


# 메인 ------------------------------------
plt.figure(figsize=(4, 4))
W=np.array([W0, W1])
mse = mse_line(X, T, W)
print("w0={0:.3f}, w1={1:.3f}".format(W0, W1))
# mse = mse_line(X, T, W)
print("SD={0:.3f} cm".format(np.sqrt(mse)))
show_line(W)
plt.plot(X, T, marker='o', linestyle='None',
         color='cornflowerblue', markeredgecolor='black')
plt.xlim(X_min, X_max)
plt.grid(True)
plt.show()

# W= array([  1.53994736, 136.17616033])

# 리스트 5-1-(11)
# 해석해 ------------------------------------
def fit_line(x, t):
    mx = np.mean(x)
    mt = np.mean(t)
    mtx = np.mean(t * x)
    mxx = np.mean(x * x)
    w0 = (mtx - mt * mx) / (mxx - mx**2)
    w1 = mt - w0 * mx
    return np.array([w0, w1])

# 메인 (기존) ------------------------------------
W = fit_line(X, T)
# w0=1.540, w1=136.176 : 수치해
# w0=1.558, w1=135.872 : 해석해
print("w0={0:.3f}, w1={1:.3f}".format(W[0], W[1]))
mse = mse_line(X, T, W)
# mse = 49.027 : 수치해
# mse = 49.012 : 해석해
print("SD={0:.3f} cm".format(np.sqrt(mse)))
plt.figure(figsize=(4, 4))
show_line(W)
plt.plot(X, T, marker='o', linestyle='None',
         color='cornflowerblue', markeredgecolor='black')
plt.xlim(X_min, X_max)
plt.grid(True)
plt.show()

# 메인 (변경) ------------------------------------
if  __name__ == '__main__':  # 리스트 5-1-(8)
    d_w = dmse_line(X, T, [10, 165])
    print(np.round(d_w, 1))

    # 수치해 메인 ------------------------------------
    plt.figure(figsize=(4, 4))
    W=np.array([W0, W1])
    mse = mse_line(X, T, W)
    print("수치해: w0={0:.3f}, w1={1:.3f}".format(W0, W1))
    # mse = mse_line(X, T, W)
    print("수치해: SD={0:.3f} cm".format(np.sqrt(mse)))
    show_line(W)
    plt.plot(X, T, marker='o', linestyle='None',
             color='cornflowerblue', markeredgecolor='black')
    plt.xlim(X_min, X_max)
    plt.grid(True)
    plt.show()

    # 해석해 메인 ------------------------------------
    W = fit_line(X, T)

    # 수치해 W: array([  1.53994736, 136.17616033])
    # 해석해 W: array([  1.55757515, 135.87192426])

    print("해석해: w0={0:.3f}, w1={1:.3f}".format(W[0], W[1]))
    mse = mse_line(X, T, W)
    print("해석해: SD={0:.3f} cm".format(np.sqrt(mse)))
    plt.figure(figsize=(4, 4))
    show_line(W)
    plt.plot(X, T, marker='o', linestyle='None',
             color='cornflowerblue', markeredgecolor='black')
    plt.xlim(X_min, X_max)
    plt.grid(True)
    plt.show()


# 리스트 5-1-(12)
# 2차원 데이터 생성 --------------------------
# X0: 나이, X1: 몸무게 (새롭게 생성함), T: 키
X0 = X # 나이
X0_min = 5
X0_max = 30
np.random.seed(seed=1) # 난수를 고정
X1 = 23 * (T / 100)**2 + 2 * np.random.randn(X_n)
# 몸무게는 T(키)와 연관되어 생성됨을 알 수 있다.
X1_min = 40
X1_max = 75

# 리스트 5-1-(13)
print('X0[나이]= ', np.round(X0, 2))
print('X1[몸무게]= ', np.round(X1, 2))
print('T[키]= ', np.round(T, 2))

# X0[나이]=  [15.43 23.01  5.   12.56  8.67  7.31  9.66 13.64 14.92 18.47 15.48 22.13
#  10.11 26.95  5.68 21.76]
# X1[몸무게]=  [70.43 58.15 37.22 56.51 57.32 40.84 57.79 56.94 63.03 65.69 62.33 64.95
#  57.73 66.89 46.68 61.08]
# T[키]=  [170.91 160.68 129.   159.7  155.46 140.56 153.65 159.43 164.7  169.65
#  160.71 173.29 159.31 171.52 138.96 165.87]


# 리스트 5-1-(14)
# 2차원 데이터의 표시 ------------------------
def show_data2(ax, x0, x1, t):
    # ax; x0=X0;  x1=X1;  t=T
    # i=0 부터 15까지 하나씩 그려보자
    for i in range(len(x0)):
        ax.plot([x0[i], x0[i]], [x1[i], x1[i]],
                [120, t[i]], color='gray')
        # x0[i], x0[i]
        # (15.42555011756435, 15.42555011756435)
        # x1[i], x1[i]
        # (70.43231869836629, 70.43231869836629)
        # 120, t[i]
        # (120, 170.91013144599378)
        ax.plot(x0, x1, t, 'o',
                color='cornflowerblue', markeredgecolor='black',
                markersize=6, markeredgewidth=0.5)
        ax.view_init(elev=35, azim=-75)


# 메인 ------------------------------------
plt.figure(figsize=(6, 5))
ax = plt.subplot(1,1,1,projection='3d')
show_data2(ax, X0, X1, T)
plt.show()

# 리스트 5-1-(15)
#면의 표시 ----------------------------------
def show_plane(ax, w):
    # ax; w=W
    # w = [1.5, 1, 90]
    # [x0 (나이), x1 (몸무게), t(키)]
    px0 = np.linspace(X0_min, X0_max, 5) #
    # X0_min, X0_max = (5, 30) : 나이 (5, 30) 범위에서 5 등분
    # array([ 5.  , 11.25, 17.5 , 23.75, 30.  ])
    px1 = np.linspace(X1_min, X1_max, 5)  #
    # X1_min, X1_max = (40, 75) : 몸무게 (40, 75) 범위에서 5 등분
    # array([40.  , 48.75, 57.5 , 66.25, 75.  ])
    px0, px1 = np.meshgrid(px0, px1)
    # px0 = --> 나이 (5, 30) 범위에서 5 등분
    # array([[ 5.  , 11.25, 17.5 , 23.75, 30.  ],
    #        [ 5.  , 11.25, 17.5 , 23.75, 30.  ],
    #        [ 5.  , 11.25, 17.5 , 23.75, 30.  ],
    #        [ 5.  , 11.25, 17.5 , 23.75, 30.  ],
    #        [ 5.  , 11.25, 17.5 , 23.75, 30.  ]])

    # px1 = --> 몸무게 (40, 75) 범위에서 5 등분
    # array([[40.  , 40.  , 40.  , 40.  , 40.  ],
    #        [48.75, 48.75, 48.75, 48.75, 48.75],
    #        [57.5 , 57.5 , 57.5 , 57.5 , 57.5 ],
    #        [66.25, 66.25, 66.25, 66.25, 66.25],
    #        [75.  , 75.  , 75.  , 75.  , 75.  ]])

    y = w[0]*px0 + w[1] * px1 + w[2]
    # 평면 모델링 실시
    # w = [1.5, 1, 90]
    # w[0] = 1.5 (나이에 대한 기울기값 )
    # w[1] = 1 (몸무게에 대한 기울기값 )
    # w[2] = 90 (키에 대한 기울기값 )

    #  w[0]*px0 :  w[0] = 1.5 (나이에 대한 기울기값 )을
    #  나이 (5, 30) 범위에서 5 등분 한 [5,5] 행렬 px0 전체에 곱함
    #  array([[ 7.5  , 16.875, 26.25 , 35.625, 45.   ],
    #        [ 7.5  , 16.875, 26.25 , 35.625, 45.   ],
    #        [ 7.5  , 16.875, 26.25 , 35.625, 45.   ],
    #        [ 7.5  , 16.875, 26.25 , 35.625, 45.   ],
    #        [ 7.5  , 16.875, 26.25 , 35.625, 45.   ]])

    # w[0]*px0 + w[1]*px1  : y 모델링 작업 중에 평면이 보이기 시작하는 부분임
    # array([[ 47.5  ,  56.875,  66.25 ,  75.625,  85.   ],
    #        [ 56.25 ,  65.625,  75.   ,  84.375,  93.75 ],
    #        [ 65.   ,  74.375,  83.75 ,  93.125, 102.5  ],
    #        [ 73.75 ,  83.125,  92.5  , 101.875, 111.25 ],
    #        [ 82.5  ,  91.875, 101.25 , 110.625, 120.   ]])

    # w[0]*px0 + w[1] * px1  : px1 90 을 더함, y 모델링 작업 중에 평면 모델링 완성
    # array([[ 47.5  ,  56.875,  66.25 ,  75.625,  85.   ],
    #        [ 56.25 ,  65.625,  75.   ,  84.375,  93.75 ],
    #        [ 65.   ,  74.375,  83.75 ,  93.125, 102.5  ],
    #        [ 73.75 ,  83.125,  92.5  , 101.875, 111.25 ],
    #        [ 82.5  ,  91.875, 101.25 , 110.625, 120.   ]])


    ax.plot_surface(px0, px1, y, rstride=1, cstride=1, alpha=0.3,
                    color='blue', edgecolor='black')
    # px0, px1, y
    # Out[76]:
    # (array([[ 5.  , 11.25, 17.5 , 23.75, 30.  ],
    #         [ 5.  , 11.25, 17.5 , 23.75, 30.  ],
    #         [ 5.  , 11.25, 17.5 , 23.75, 30.  ],
    #         [ 5.  , 11.25, 17.5 , 23.75, 30.  ],
    #         [ 5.  , 11.25, 17.5 , 23.75, 30.  ]]),
    #  array([[40.  , 40.  , 40.  , 40.  , 40.  ],
    #         [48.75, 48.75, 48.75, 48.75, 48.75],
    #         [57.5 , 57.5 , 57.5 , 57.5 , 57.5 ],
    #         [66.25, 66.25, 66.25, 66.25, 66.25],
    #         [75.  , 75.  , 75.  , 75.  , 75.  ]]),
    #  array([[137.5  , 146.875, 156.25 , 165.625, 175.   ],
    #         [146.25 , 155.625, 165.   , 174.375, 183.75 ],
    #         [155.   , 164.375, 173.75 , 183.125, 192.5  ],
    #         [163.75 , 173.125, 182.5  , 191.875, 201.25 ],
    #         [172.5  , 181.875, 191.25 , 200.625, 210.   ]]))
    # t[0] : 170.91013144599378
    # t
    # array([170.91013145, 160.67559882, 129.00206616, 159.70139552,
    #        155.46058905, 140.56134369, 153.65466385, 159.42939554,
    #        164.70423898, 169.64527574, 160.71257522, 173.28709855,
    #        159.31193249, 171.51757345, 138.9570433 , 165.8744074 ])

    # x0 (실제 나이) : np.round(x0, 2)
    # array([15.43, 23.01,  5.  , 12.56,  8.67,  7.31,  9.66, 13.64, 14.92,
    #        18.47, 15.48, 22.13, 10.11, 26.95,  5.68, 21.76])
    # x1 (실제 몸무게) : np.round(x1, 2)
    # array([70.43, 58.15, 37.22, 56.51, 57.32, 40.84, 57.79, 56.94, 63.03,
    #        65.69, 62.33, 64.95, 57.73, 66.89, 46.68, 61.08])
    # t (실제 키) : np.round(t, 2)
    # array([170.91, 160.68, 129.  , 159.7 , 155.46, 140.56, 153.65, 159.43,
    #        164.7 , 169.65, 160.71, 173.29, 159.31, 171.52, 138.96, 165.87])



#면의 MSE -----------------------------------
def mse_plane(x0, x1, t, w):
    # w = [1.5, 1, 90]
    y = w[0] * x0 + w[1] * x1 + w[2] # (A)
    mse = np.mean((y - t)**2)
    return mse

# 메인 ------------------------------------
plt.figure(figsize=(6, 5))
ax = plt.subplot(1, 1, 1, projection='3d')
W = [1.5, 1, 90]
show_plane(ax, W)
show_data2(ax, X0, X1, T)
mse = mse_plane(X0, X1, T, W)
print("SD={0:.3f} cm".format(np.sqrt(mse)))
plt.show()

# 리스트 5-1-(16)
# 해석해 ------------------------------------
def fit_plane(x0, x1, t):
    c_tx0 = np.mean(t * x0) - np.mean(t) * np.mean(x0)
    c_tx1 = np.mean(t * x1) - np.mean(t) * np.mean(x1)
    c_x0x1 = np.mean(x0 * x1) - np.mean(x0) * np.mean(x1)
    v_x0 = np.var(x0)
    v_x1 = np.var(x1)
    w0 = (c_tx1 * c_x0x1 - v_x1 * c_tx0) / (c_x0x1**2 - v_x0 * v_x1)
    w1 = (c_tx0 * c_x0x1 - v_x0 * c_tx1) / (c_x0x1**2 - v_x0 * v_x1)
    w2 = -w0 * np.mean(x0) - w1 * np.mean(x1) + np.mean(t)
    return np.array([w0, w1, w2])


# 메인 ------------------------------------
plt.figure(figsize=(6, 5))
ax = plt.subplot(1, 1, 1, projection='3d')
W = fit_plane(X0, X1, T)
print("w0={0:.1f}, w1={1:.1f}, w2={2:.1f}".format(W[0], W[1], W[2]))
show_plane(ax, W)
show_data2(ax, X0, X1, T)
mse = mse_plane(X0, X1, T, W)
print("SD={0:.3f} cm".format(np.sqrt(mse)))
plt.show()

# Commented out IPython magic to ensure Python compatibility.
# --- 리스트 5-2-(1)
import numpy as np
import matplotlib.pyplot as plt
# %matplotlib inline


# 데이터 로드 ----------------------------
outfile = np.load('ch5_data.npz')
X = outfile['X']
X_min = outfile['X_min']
X_max = outfile['X_max']
X_n = outfile['X_n']
T = outfile['T']

# --- 리스트 5-2-(2)
# 가우스 함수 ---------------------------------
def gauss(x, mu, s):
    return np.exp(-(x - mu)**2 / (2 * s**2))

# 리스트 5-2-(3)
# 메인 ------------------------------------
M = 4
plt.figure(figsize=(4, 4))
mu = np.linspace(5, 30, M)
# np.round(mu,2)
# array([ 5.  , 13.33, 21.67, 30.  ])
s = mu[1] - mu[0] # (A)
# np.round(s, 2)=  8.33
xb = np.linspace(X_min, X_max, 100)
# np.round(xb, 2)
# array([ 4.  ,  4.26,  4.53,  4.79,  5.05,  5.31,  5.58,  5.84,  6.1 ,
#         6.36,  6.63,  6.89,  7.15,  7.41,  7.68,  7.94,  8.2 ,  8.46,
#         8.73,  8.99,  9.25,  9.52,  9.78, 10.04, 10.3 , 10.57, 10.83,
#        11.09, 11.35, 11.62, 11.88, 12.14, 12.4 , 12.67, 12.93, 13.19,
#        13.45, 13.72, 13.98, 14.24, 14.51, 14.77, 15.03, 15.29, 15.56,
#        15.82, 16.08, 16.34, 16.61, 16.87, 17.13, 17.39, 17.66, 17.92,
#        18.18, 18.44, 18.71, 18.97, 19.23, 19.49, 19.76, 20.02, 20.28,
#        20.55, 20.81, 21.07, 21.33, 21.6 , 21.86, 22.12, 22.38, 22.65,
#        22.91, 23.17, 23.43, 23.7 , 23.96, 24.22, 24.48, 24.75, 25.01,
#        25.27, 25.54, 25.8 , 26.06, 26.32, 26.59, 26.85, 27.11, 27.37,
#        27.64, 27.9 , 28.16, 28.42, 28.69, 28.95, 29.21, 29.47, 29.74,
#        30.  ])

for j in range(M):
    y = gauss(xb, mu[j], s)
    # j=0 일 때 첫번째 가우스 모델링 함수 y 생성
    # np.round(y,2)
    # array([0.99, 1.  , 1.  , 1.  , 1.  , 1.  , 1.  , 0.99, 0.99, 0.99, 0.98,
    #        0.97, 0.97, 0.96, 0.95, 0.94, 0.93, 0.92, 0.9 , 0.89, 0.88, 0.86,
    #        0.85, 0.83, 0.82, 0.8 , 0.78, 0.77, 0.75, 0.73, 0.71, 0.69, 0.67,
    #        0.65, 0.64, 0.62, 0.6 , 0.58, 0.56, 0.54, 0.52, 0.5 , 0.48, 0.47,
    #        0.45, 0.43, 0.41, 0.4 , 0.38, 0.36, 0.35, 0.33, 0.32, 0.3 , 0.29,
    #        0.27, 0.26, 0.25, 0.23, 0.22, 0.21, 0.2 , 0.19, 0.18, 0.17, 0.16,
    #        0.15, 0.14, 0.13, 0.12, 0.11, 0.11, 0.1 , 0.09, 0.09, 0.08, 0.08,
    #        0.07, 0.06, 0.06, 0.06, 0.05, 0.05, 0.04, 0.04, 0.04, 0.03, 0.03,
    #        0.03, 0.03, 0.02, 0.02, 0.02, 0.02, 0.02, 0.02, 0.01, 0.01, 0.01,
    #        0.01])
    plt.plot(xb, y, color='gray', linewidth=3)

    # j=1
    # np.round(y,2)
    # array([0.53, 0.55, 0.57, 0.59, 0.61, 0.63, 0.65, 0.67, 0.69, 0.7 , 0.72,
    #        0.74, 0.76, 0.78, 0.79, 0.81, 0.83, 0.84, 0.86, 0.87, 0.89, 0.9 ,
    #        0.91, 0.92, 0.94, 0.95, 0.96, 0.96, 0.97, 0.98, 0.98, 0.99, 0.99,
    #        1.  , 1.  , 1.  , 1.  , 1.  , 1.  , 0.99, 0.99, 0.99, 0.98, 0.97,
    #        0.97, 0.96, 0.95, 0.94, 0.93, 0.91, 0.9 , 0.89, 0.87, 0.86, 0.84,
    #        0.83, 0.81, 0.8 , 0.78, 0.76, 0.74, 0.72, 0.71, 0.69, 0.67, 0.65,
    #        0.63, 0.61, 0.59, 0.57, 0.55, 0.54, 0.52, 0.5 , 0.48, 0.46, 0.44,
    #        0.43, 0.41, 0.39, 0.37, 0.36, 0.34, 0.33, 0.31, 0.3 , 0.28, 0.27,
    #        0.25, 0.24, 0.23, 0.22, 0.21, 0.19, 0.18, 0.17, 0.16, 0.15, 0.14,
    #        0.14])

    # j=2
    # y = gauss(xb, mu[j], s)
    # np.round(y,2)
    # array([0.11, 0.11, 0.12, 0.13, 0.14, 0.15, 0.16, 0.16, 0.17, 0.19, 0.2 ,
    #        0.21, 0.22, 0.23, 0.24, 0.26, 0.27, 0.29, 0.3 , 0.31, 0.33, 0.35,
    #        0.36, 0.38, 0.39, 0.41, 0.43, 0.45, 0.46, 0.48, 0.5 , 0.52, 0.54,
    #        0.56, 0.58, 0.6 , 0.62, 0.63, 0.65, 0.67, 0.69, 0.71, 0.73, 0.75,
    #        0.76, 0.78, 0.8 , 0.82, 0.83, 0.85, 0.86, 0.88, 0.89, 0.9 , 0.92,
    #        0.93, 0.94, 0.95, 0.96, 0.97, 0.97, 0.98, 0.99, 0.99, 0.99, 1.  ,
    #        1.  , 1.  , 1.  , 1.  , 1.  , 0.99, 0.99, 0.98, 0.98, 0.97, 0.96,
    #        0.95, 0.94, 0.93, 0.92, 0.91, 0.9 , 0.88, 0.87, 0.86, 0.84, 0.82,
    #        0.81, 0.79, 0.77, 0.76, 0.74, 0.72, 0.7 , 0.68, 0.66, 0.64, 0.63,
    #        0.61])

    # j=3
    # y = gauss(xb, mu[j], s)
    # np.round(y, 2)
    # array([0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.02, 0.02, 0.02,
    #        0.02, 0.02, 0.03, 0.03, 0.03, 0.03, 0.04, 0.04, 0.04, 0.05, 0.05,
    #        0.05, 0.06, 0.06, 0.07, 0.07, 0.08, 0.08, 0.09, 0.09, 0.1 , 0.11,
    #        0.11, 0.12, 0.13, 0.14, 0.15, 0.16, 0.17, 0.18, 0.19, 0.2 , 0.21,
    #        0.22, 0.24, 0.25, 0.26, 0.27, 0.29, 0.3 , 0.32, 0.33, 0.35, 0.37,
    #        0.38, 0.4 , 0.42, 0.43, 0.45, 0.47, 0.49, 0.51, 0.53, 0.54, 0.56,
    #        0.58, 0.6 , 0.62, 0.64, 0.66, 0.68, 0.7 , 0.71, 0.73, 0.75, 0.77,
    #        0.79, 0.8 , 0.82, 0.84, 0.85, 0.87, 0.88, 0.89, 0.91, 0.92, 0.93,
    #        0.94, 0.95, 0.96, 0.97, 0.98, 0.98, 0.99, 0.99, 1.  , 1.  , 1.  ,
    #        1.  ])


plt.grid(True)
plt.xlim(X_min, X_max)
plt.ylim(0, 1.2)
plt.show()

# 리스트 5-2-(4)
# 선형 기저 함수 모델 ----------------
def gauss_func(w, x):
    # w; x=xb
    # np.round(w) = array([29., 76.,  3., 98., 55.])
    m = len(w) - 1
    # m=4
    mu = np.linspace(5, 30, m)
    # np.round(mu)=array([ 5., 13., 22., 30.])

    s = mu[1] - mu[0]
    # s=8.3
    y = np.zeros_like(x) # x와 같은 크기로 요소가 0의 행렬 y를 작성
    # y
    # array([0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
    #        0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
    #        0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
    #        0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
    #        0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
    #        0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.])

    for j in range(m):
        y = y + w[j] * gauss(x, mu[j], s)
        # j=0
        # np.round(y)
        # array([29., 29., 29., 29., 29., 29., 29., 29., 29., 29., 29., 29., 28.,
        #        28., 28., 28., 27., 27., 27., 26., 26., 25., 25., 24., 24., 24.,
        #        23., 22., 22., 21., 21., 20., 20., 19., 19., 18., 18., 17., 16.,
        #        16., 15., 15., 14., 14., 13., 13., 12., 12., 11., 11., 10., 10.,
        #         9.,  9.,  8.,  8.,  8.,  7.,  7.,  6.,  6.,  6.,  5.,  5.,  5.,
        #         5.,  4.,  4.,  4.,  4.,  3.,  3.,  3.,  3.,  3.,  2.,  2.,  2.,
        #         2.,  2.,  2.,  2.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,
        #         1.,  1.,  1.,  1.,  0.,  0.,  0.,  0.,  0.])

        # j=1
        # y = y + w[j] * gauss(x, mu[j], s)
        # np.round(y)
        # array([70., 71., 73., 74., 76., 77., 78., 80., 81., 82., 84., 85., 86.,
        #        87., 88., 89., 90., 91., 92., 92., 93., 93., 94., 94., 95., 95.,
        #        95., 95., 96., 96., 95., 95., 95., 95., 94., 94., 93., 93., 92.,
        #        91., 90., 89., 88., 87., 86., 85., 84., 83., 81., 80., 78., 77.,
        #        75., 74., 72., 71., 69., 67., 66., 64., 62., 61., 59., 57., 55.,
        #        54., 52., 50., 49., 47., 45., 44., 42., 40., 39., 37., 36., 34.,
        #        33., 31., 30., 29., 27., 26., 25., 24., 22., 21., 20., 19., 18.,
        #        17., 16., 15., 14., 14., 13., 12., 11., 11.])

        # j=2
        # y = y + w[j] * gauss(x, mu[j], s)
        # np.round(y)
        # array([70., 71., 73., 74., 76., 77., 79., 80., 82., 83., 84., 85., 87.,
        #        88., 89., 90., 91., 92., 92., 93., 94., 94., 95., 96., 96., 96.,
        #        97., 97., 97., 97., 97., 97., 97., 96., 96., 95., 95., 94., 94.,
        #        93., 92., 91., 90., 89., 88., 87., 86., 85., 84., 82., 81., 79.,
        #        78., 76., 75., 73., 72., 70., 68., 67., 65., 63., 62., 60., 58.,
        #        57., 55., 53., 51., 50., 48., 46., 45., 43., 42., 40., 39., 37.,
        #        36., 34., 33., 31., 30., 29., 27., 26., 25., 24., 22., 21., 20.,
        #        19., 18., 17., 16., 15., 15., 14., 13., 12.])

        # j=3
        # y = y + w[j] * gauss(x, mu[j], s)
        # np.round(y)
        # array([ 71.,  72.,  74.,  75.,  77.,  79.,  80.,  82.,  83.,  85.,  86.,
        #         87.,  89.,  90.,  91.,  93.,  94.,  95.,  96.,  97.,  98.,  99.,
        #        100., 101., 102., 103., 104., 104., 105., 106., 106., 107., 107.,
        #        108., 108., 108., 109., 109., 109., 109., 110., 110., 110., 110.,
        #        110., 110., 110., 111., 111., 111., 111., 111., 111., 111., 111.,
        #        111., 111., 111., 111., 111., 111., 111., 112., 112., 112., 112.,
        #        112., 112., 112., 113., 113., 113., 113., 113., 114., 114., 114.,
        #        114., 114., 115., 115., 115., 115., 115., 115., 115., 115., 115.,
        #        115., 115., 115., 114., 114., 114., 113., 113., 112., 112., 111.,
        #        111.])
        # 아직 y 가 키 값같이 보이지 않는다.
        # 바이어스, w[m] 가 필요하다

    y = y + w[m]
    # y = y + w[m]
    # np.round(y)
    # w[m]를 더함으로 아래 y 가 키 값같이 보인다.
    # array([126., 127., 129., 130., 132., 133., 135., 137., 138., 139., 141.,
    #        142., 144., 145., 146., 148., 149., 150., 151., 152., 153., 154.,
    #        155., 156., 157., 158., 158., 159., 160., 160., 161., 162., 162.,
    #        162., 163., 163., 164., 164., 164., 164., 165., 165., 165., 165.,
    #        165., 165., 165., 165., 165., 166., 166., 166., 166., 166., 166.,
    #        166., 166., 166., 166., 166., 166., 166., 166., 167., 167., 167.,
    #        167., 167., 167., 168., 168., 168., 168., 168., 169., 169., 169.,
    #        169., 169., 170., 170., 170., 170., 170., 170., 170., 170., 170.,
    #        170., 170., 170., 169., 169., 169., 168., 168., 167., 167., 166.,
    #        165.])

    return y

# 리스트 5-2-(5)
# 선형 기저 함수 모델 MSE ----------------
def mse_gauss_func(x, t, w):
    # x=X; t=T; w=W
    # np.round(x)
    # array([15., 23.,  5., 13.,  9.,  7., 10., 14., 15., 18., 15., 22., 10.,
    #        27.,  6., 22.])
    # np.round(t)
    # array([171., 161., 129., 160., 155., 141., 154., 159., 165., 170., 161.,
    #        173., 159., 172., 139., 166.])
    # np.round(w)
    # array([29., 76.,  3., 98., 55.])
    y = gauss_func(w, x)
    # np.round(y)
    # array([165., 168., 132., 162., 151., 144., 155., 164., 165., 166., 165.,
    #        168., 156., 170., 136., 167.])

    mse = np.mean((y - t)**2)
    # np.round(y-t)
    # array([-6.,  8.,  3.,  3., -5.,  4.,  1.,  4.,  0., -4.,  4., -6., -3.,
    #        -2., -3.,  1.])
    # np.round((y - t)**2)
    # array([34., 57.,  7.,  7., 22., 15.,  1., 19.,  0., 15., 19., 33.,  9.,
    #         2., 11.,  2.])

    return mse

# 리스트 5-2-(6)
# 선형 기저 함수 모델 정확한 솔루션 (해석해) -----------------
def fit_gauss_func(x, t, m):
    # x=X; t=T; m=M
    # np.round(x, 2) # 나이
    # np.round(x, 2)
    # array([15.43, 23.01,  5.  , 12.56,  8.67,  7.31,  9.66, 13.64, 14.92,
    #        18.47, 15.48, 22.13, 10.11, 26.95,  5.68, 21.76])
    # np.round(t, 2)  # 키
    # np.round(t, 2)
    # array([170.91, 160.68, 129.  , 159.7 , 155.46, 140.56, 153.65, 159.43,
    #        164.7 , 169.65, 160.71, 173.29, 159.31, 171.52, 138.96, 165.87])

    mu = np.linspace(5, 30, m)
    # np.round(mu, 2)
    # array([ 5.  , 13.33, 21.67, 30.  ])

    s = mu[1] - mu[0]
    # s= 8.33
    n = x.shape[0]
    # n= 16

    psi = np.ones((n, m+1)) # n=16, m+1=5
    # psi
    # array([[1., 1., 1., 1., 1.],
    #        [1., 1., 1., 1., 1.],
    #        [1., 1., 1., 1., 1.],
    #        [1., 1., 1., 1., 1.],


    for j in range(m):
        psi[:, j] = gauss(x, mu[j], s)
        # j=0
        # psi[:, j] = gauss(x, mu[j], s)
        # np.round(psi, 2)
        # array([[0.46, 1.  , 1.  , 1.  , 1.  ],
        #        [0.1 , 1.  , 1.  , 1.  , 1.  ],
        #        [1.  , 1.  , 1.  , 1.  , 1.  ],
        #        [0.66, 1.  , 1.  , 1.  , 1.  ],
        #        [0.91, 1.  , 1.  , 1.  , 1.  ],
        #        [0.96, 1.  , 1.  , 1.  , 1.  ],
        #        [0.86, 1.  , 1.  , 1.  , 1.  ],
        #        [0.58, 1.  , 1.  , 1.  , 1.  ],
        #        [0.49, 1.  , 1.  , 1.  , 1.  ],
        #        [0.27, 1.  , 1.  , 1.  , 1.  ],
        #        [0.45, 1.  , 1.  , 1.  , 1.  ],

        # j=1
        # np.round(psi, 2)
        # array([[0.46, 0.97, 1.  , 1.  , 1.  ],
        #        [0.1 , 0.51, 1.  , 1.  , 1.  ],
        #        [1.  , 0.61, 1.  , 1.  , 1.  ],
        #        [0.66, 1.  , 1.  , 1.  , 1.  ],
        #        [0.91, 0.86, 1.  , 1.  , 1.  ],
        #        [0.96, 0.77, 1.  , 1.  , 1.  ],
        #        [0.86, 0.91, 1.  , 1.  , 1.  ],
        #        [0.58, 1.  , 1.  , 1.  , 1.  ],
        #        [0.49, 0.98, 1.  , 1.  , 1.  ],

        # np.round(psi, 2)
        # array([[0.46, 0.97, 0.76, 0.22, 1.  ],
        #        [0.1 , 0.51, 0.99, 0.7 , 1.  ],
        #        [1.  , 0.61, 0.14, 0.01, 1.  ],
        #        [0.66, 1.  , 0.55, 0.11, 1.  ],
        #        [0.91, 0.86, 0.3 , 0.04, 1.  ],

    psi_T = np.transpose(psi)
    # psi_T = np.transpose(psi)
    # np.round(psi_T, 2)
    # array([[0.46, 0.1 , 1.  , 0.66, 0.91, 0.96, 0.86, 0.58, 0.49, 0.27, 0.45,
    #         0.12, 0.83, 0.03, 1.  , 0.13],
    #        [0.97, 0.51, 0.61, 1.  , 0.86, 0.77, 0.91, 1.  , 0.98, 0.83, 0.97,
    #         0.57, 0.93, 0.26, 0.66, 0.6 ],
    #        [0.76, 0.99, 0.14, 0.55, 0.3 , 0.23, 0.35, 0.63, 0.72, 0.93, 0.76,
    #         1.  , 0.38, 0.82, 0.16, 1.  ],
    #        [0.22, 0.7 , 0.01, 0.11, 0.04, 0.02, 0.05, 0.15, 0.19, 0.38, 0.22,
    #         0.64, 0.06, 0.94, 0.01, 0.61],
    #        [1.  , 1.  , 1.  , 1.  , 1.  , 1.  , 1.  , 1.  , 1.  , 1.  , 1.  ,
    #         1.  , 1.  , 1.  , 1.  , 1.  ]])



    b = np.linalg.inv(psi_T.dot(psi))
    # np.round(b, 2)
    # array([[ 178.82,   21.65,  108.16,  116.13, -212.95],
    #        [  21.65,   17.14,    2.15,   31.22,  -35.09],
    #        [ 108.16,    2.15,   75.72,   55.54, -122.55],
    #        [ 116.13,   31.22,   55.54,   97.98, -148.84],
    #        [-212.95,  -35.09, -122.55, -148.84,  259.96]])

    c = b.dot(psi_T)
    # np.round(c, 2)
    # array([[-3.34,  3.83, -5.05, -0.37,  4.3 ,  3.18,  3.85, -1.92, -3.12,
    #         -1.55, -3.36,  3.41,  3.39, -4.63, -1.68,  3.07],
    #        [-0.19, -0.17, -2.39,  1.01,  1.04,  0.2 ,  1.34,  0.59,  0.03,
    #         -1.06, -0.21, -0.51,  1.39,  1.06, -1.47, -0.64],
    #        [-1.78,  2.82, -2.22, -0.85,  1.99,  1.72,  1.55, -1.51, -1.82,
    #          0.19, -1.77,  2.92,  1.23, -4.76, -0.52,  2.83],
    #        [-2.31,  2.05, -5.16,  0.74,  3.41,  1.95,  3.46, -0.61, -1.92,
    #         -2.35, -2.34,  1.27,  3.26,  0.05, -2.4 ,  0.88],
    #        [ 3.77, -4.19,  7.47, -0.21, -5.26, -3.42, -4.99,  1.75,  3.4 ,
    #          2.27,  3.79, -3.54, -4.52,  4.68,  3.11, -3.09]])

    w = c.dot(t)
    # w = c.dot(t)
    # np.round(w, 2)
    # array([29.39, 75.66,  2.86, 98.28, 54.88])

    return w

# 리스트 5-2-(7)
# 가우스 기저 함수 표시 -----------------------
def show_gauss_func(w):
    # w=W
    # np.round(W)
    # array([29., 76.,  3., 98., 55.])
    xb = np.linspace(X_min, X_max, 100)
    # np.round(xb)
    # array([ 4.,  4.,  5.,  5.,  5.,  5.,  6.,  6.,  6.,  6.,  7.,  7.,  7.,
    #         7.,  8.,  8.,  8.,  8.,  9.,  9.,  9., 10., 10., 10., 10., 11.,
    #        11., 11., 11., 12., 12., 12., 12., 13., 13., 13., 13., 14., 14.,
    #        14., 15., 15., 15., 15., 16., 16., 16., 16., 17., 17., 17., 17.,
    #        18., 18., 18., 18., 19., 19., 19., 19., 20., 20., 20., 21., 21.,
    #        21., 21., 22., 22., 22., 22., 23., 23., 23., 23., 24., 24., 24.,
    #        24., 25., 25., 25., 26., 26., 26., 26., 27., 27., 27., 27., 28.,
    #        28., 28., 28., 29., 29., 29., 29., 30., 30.])

    y = gauss_func(w, xb)
    plt.plot(xb, y, c=[.5, .5, .5], lw=4)


# 메인 ----------------------------------
plt.figure(figsize=(4, 4))
M = 4
W = fit_gauss_func(X, T, M)
# np.round(W)
#  array([29., 76.,  3., 98., 55.])

show_gauss_func(W)
plt.plot(X, T, marker='o', linestyle='None',
         color='cornflowerblue', markeredgecolor='black')
plt.xlim(X_min, X_max)
plt.grid(True)
mse = mse_gauss_func(X, T, W)
print('W='+ str(np.round(W,1)))
print("SD={0:.2f} cm".format(np.sqrt(mse)))
plt.show()

# 리스트 5-2-(8)
# 오버피팅
plt.figure(figsize=(10, 2.5))
plt.subplots_adjust(wspace=0.3)
M = [2, 4, 7, 9]
for i in range(len(M)):
    plt.subplot(1, len(M), i + 1)
    W = fit_gauss_func(X, T, M[i])
    show_gauss_func(W)
    plt.plot(X, T, marker='o', linestyle='None',
             color='cornflowerblue', markeredgecolor='black')
    plt.xlim(X_min, X_max)
    plt.grid(True)
    plt.ylim(130, 180)
    mse = mse_gauss_func(X, T, W)


    plt.title("M={0:d}, SD={1:.1f}".format(M[i], np.sqrt(mse)))
plt.show()

# 리스트 5-2-(9)
plt.figure(figsize=(5, 4))
M = range(2, 10)
mse2 = np.zeros(len(M))
for i in range(len(M)):
    W = fit_gauss_func(X, T, M[i])
    mse2[i] = np.sqrt(mse_gauss_func(X, T, W))
plt.plot(M, mse2, marker='o',
         color='cornflowerblue', markeredgecolor='black')
plt.grid(True)
plt.show()

# 리스트 5-2-(10)
# 훈련 데이터와 테스트 데이터 ------------------
X_test = X[:int(X_n / 4 + 1)]
T_test = T[:int(X_n / 4 + 1)]
X_train = X[int(X_n / 4 + 1):]
T_train = T[int(X_n / 4 + 1):]
# 메인 ------------------------------------
plt.figure(figsize=(10, 2.5))


plt.subplots_adjust(wspace=0.3)
M = [2, 4, 7, 9]
for i in range(len(M)):
    plt.subplot(1, len(M), i + 1)
    W = fit_gauss_func(X_train, T_train, M[i])
    show_gauss_func(W)
    plt.plot(X_train, T_train, marker='o',
             linestyle='None', color='white',
             markeredgecolor='black', label='training')
    plt.plot(X_test, T_test, marker='o', linestyle='None',
             color='cornflowerblue',
             markeredgecolor='black', label='test')
    plt.legend(loc='lower right', fontsize=10, numpoints=1)
    plt.xlim(X_min, X_max)
    plt.ylim(130, 180)
    plt.grid(True)
    mse = mse_gauss_func(X_test, T_test, W)
    plt.title("M={0:d}, SD={1:.1f}".format(M[i], np.sqrt(mse)))
plt.show()

# 리스트 5-2-(11)
plt.figure(figsize=(5, 4))
M = range(2, 10)
mse_train = np.zeros(len(M))
mse_test = np.zeros(len(M))
for i in range(len(M)):
    W = fit_gauss_func(X_train, T_train, M[i])
    mse_train[i] = np.sqrt(mse_gauss_func(X_train, T_train, W))
    mse_test[i] = np.sqrt(mse_gauss_func(X_test, T_test, W))
plt.plot(M, mse_train, marker='o', linestyle='-',
         markerfacecolor='white', markeredgecolor='black',
         color='black', label='training')
plt.plot(M, mse_test, marker='o', linestyle='-',
         color='cornflowerblue', markeredgecolor='black',
         label='test')
plt.legend(loc='upper left', fontsize=10)
plt.ylim(0, 12)
plt.grid(True)
plt.show()

# 리스트 5-2-(12)
# K 분할 교차 검증 -----------------------------
def kfold_gauss_func(x, t, m, k):
    n = x.shape[0]
    mse_train = np.zeros(k)
    mse_test = np.zeros(k)
    for i in range(0, k):
        x_train = x[np.fmod(range(n), k) != i] # (A)
        t_train = t[np.fmod(range(n), k) != i] # (A)
        x_test = x[np.fmod(range(n), k) == i] # (A)
        t_test = t[np.fmod(range(n), k) == i] # (A)
        wm = fit_gauss_func(x_train, t_train, m)
        mse_train[i] = mse_gauss_func(x_train, t_train, wm)
        mse_test[i] = mse_gauss_func(x_test, t_test, wm)
    return mse_train, mse_test

# 리스트 5-2-(13)
np.fmod(range(10),5)

# 리스트 5-2-(14)
M = 4
K = 4
kfold_gauss_func(X, T, M, K)

# 리스트 5-2-(15)
M = range(2, 8)
K = 16
Cv_Gauss_train = np.zeros((K, len(M)))
Cv_Gauss_test = np.zeros((K, len(M)))
for i in range(0, len(M)):
    Cv_Gauss_train[:, i], Cv_Gauss_test[:, i] =\
                    kfold_gauss_func(X, T, M[i], K)
mean_Gauss_train = np.sqrt(np.mean(Cv_Gauss_train, axis=0))
mean_Gauss_test = np.sqrt(np.mean(Cv_Gauss_test, axis=0))


plt.figure(figsize=(4, 3))
plt.plot(M, mean_Gauss_train, marker='o', linestyle='-',
         color='k', markerfacecolor='w', label='training')
plt.plot(M, mean_Gauss_test, marker='o', linestyle='-',
         color='cornflowerblue', markeredgecolor='black', label='test')
plt.legend(loc='upper left', fontsize=10)
plt.ylim(0, 20)
plt.grid(True)
plt.show()

# 리스트 5-2-(16)
M = 3
plt.figure(figsize=(4, 4))
W = fit_gauss_func(X, T, M)
show_gauss_func(W)
plt.plot(X, T, marker='o', linestyle='None',
         color='cornflowerblue', markeredgecolor='black')
plt.xlim([X_min, X_max])
plt.grid(True)
mse = mse_gauss_func(X, T, W)
print("SD={0:.2f} cm".format(np.sqrt(mse)))
plt.show()

# 리스트 5-2-(17)
# 모델 A -----------------------------------
def model_A(x, w):
    y = w[0] - w[1] * np.exp(-w[2] * x)
    return y


# 모델 A 표시 -------------------------------
def show_model_A(w):
    xb = np.linspace(X_min, X_max, 100)
    y = model_A(xb, w)
    plt.plot(xb, y, c=[.5, .5, .5], lw=4)


# 모델 A의 MSE ------------------------------
def mse_model_A(w, x, t):
    y = model_A(x, w)
    mse = np.mean((y - t)**2)
    return mse

# 리스트 5-2-(18)
from scipy.optimize import minimize


# 모델 A의 매개 변수 최적화 -----------------
def fit_model_A(w_init, x, t):
    res1 = minimize(mse_model_A, w_init, args=(x, t), method="powell")
    return res1.x

# 리스트 5-2-(19)
# 메인 ------------------------------------
plt.figure(figsize=(4, 4))
W_init=[100, 0, 0]
W = fit_model_A(W_init, X, T)
print("w0={0:.1f}, w1={1:.1f}, w2={2:.1f}".format(W[0], W[1], W[2]))
show_model_A(W)
plt.plot(X, T, marker='o', linestyle='None',
         color='cornflowerblue',markeredgecolor='black')
plt.xlim(X_min, X_max)
plt.grid(True)
mse = mse_model_A(W, X, T)
print("SD={0:.2f} cm".format(np.sqrt(mse)))
plt.show()

# 리스트 5-2-(20)
# 교차 검증 model_A ---------------------------
def kfold_model_A(x, t, k):
    n = len(x)
    mse_train = np.zeros(k)
    mse_test = np.zeros(k)
    for i in range(0, k):
        x_train = x[np.fmod(range(n), k) != i]
        t_train = t[np.fmod(range(n), k) != i]
        x_test = x[np.fmod(range(n), k) == i]
        t_test = t[np.fmod(range(n), k) == i]
        wm = fit_model_A(np.array([169, 113, 0.2]), x_train, t_train)
        mse_train[i] = mse_model_A(wm, x_train, t_train)
        mse_test[i] = mse_model_A(wm, x_test, t_test)
    return mse_train, mse_test


# 메인 ------------------------------------
K = 16
Cv_A_train, Cv_A_test = kfold_model_A(X, T, K)
mean_A_test = np.sqrt(np.mean(Cv_A_test))
print("Gauss(M=3) SD={0:.2f} cm".format(mean_Gauss_test[1]))
print("Model A SD={0:.2f} cm".format(mean_A_test))
SD = np.append(mean_Gauss_test[0:5], mean_A_test)
M = range(6)
label = ["M=2", "M=3", "M=4", "M=5", "M=6", "Model A"]
plt.figure(figsize=(5, 3))
plt.bar(M, SD, tick_label=label, align="center",
facecolor="cornflowerblue")
plt.show()
